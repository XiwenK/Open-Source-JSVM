Java字节码、Java虚拟机、JIT编译器							

JS虚拟机														

Garbage Collector、Runtime system、Managed Runtime

解释器、语法分析、语义分析、编译优化

P-code 及 P-code虚拟机			

ARM汇编、X86汇编							



#### Java 虚拟机 

1. Java 内存区域

- 虚拟机栈和本地方法栈：VM stack 为执行 java 方法服务，native stack 为执行本地方法服务
- Java 堆
  - 存放对象实例和数组，是 GC 管理的主要区域
  - 可能被划分以便于内存管理，但存储内容不变
  - -Xmx 用来设置你的应用程序 (不是 JVM) 能够使用的最大内存数，-Xms 用来设置程序初始化的时候内存栈的大小
- 方法区
  - 存储已被 JVM 加载的类信息、常量、静态变量、JIT 编译后的代码
  - 内存回收目标：常量池回收、类型卸载
- 对象创建
  - new --> 检查指令参数能否在常量池中定位到类的符号引用，检查该类是否已被加载解析和初始化 --> 分配内存 --> 空间初始化为 0 -->设置对象必要信息 --> 执行 init
  - 内存分配
    - 指针碰撞 or 空闲列表：取决于 java 堆是否规整，取决于GC 算法是否有 compact
    - TLAB：本地线程缓冲，为线程预分配的内存空间
  - 对象的内存布局
    - 对象头
      - 存储对象自身的运行时数据
      - 类型指针：确定对象的类
      - 若为数组还应记录数组长度
    - 实例数据
      - 各类型的字段内容，存储顺序受 JVM 分配策略参数和字段在 Java 源码中定义的顺序决定
      - 同宽度在一起，父类定义出现早（默认）
    - 对齐填充：8B 整数倍
  - 对象访问定位
    - 句柄
      - 定位到 Java 堆中句柄池，池中存放到对象实例数据和类型数据的指针
      - 3 次定位，但 GC 时不需改动句柄
    - 直接指针
      - 直接定位到堆中内存
      - 2 次定位，GC 时指针改变



2. 垃圾收集

- 引用计数算法
  - 引用 + 1，失效 - 1 ，为 0 回收
  - 无法解决对象间相互循环引用
- 可达性分析：GC roots 可达
  - GC roots：
    - VM stack 中本地变量表引用的对象
    - 方法区中类静态属性引用的对象
    - 常量引用的对象
    - 本地方法引用的对象
  - finalize ()：每个覆盖了该方法的对象的该方法只会被 JVM 执行一次 
- 引用分类：
  - 强引用：new 只要存在就不会被回收
  - 软引用：有用但非必要
  - 弱引用：只能生存到下次 GC 之前
  - 虚引用：回收时能收到通知
- 标记 - 清除算法：引用计数：低效、产生空间碎片、回收老生代

- 复制算法：内存分两块，半区回收、复制整理到另一半区
  - 回收新生代：1 Eden (80%) + 2 survivor (20%)
- 标记 - 整理算法：清除后移动至一端、回收老生代
- HotSpot GC 实现
  - 枚举根节点：停掉所有线程
  - Safepoint & safe region
- CMS GC 收集器
  - 获取最短回收停顿时间
  - 并发、无法处理浮动垃圾、碎片问题
- 内存分配与回收策略
  - 原则：
    - 优先分配在新生代 Eden 区
    - 大对象（字符串、数组）直接进入老年代
    - 达到年限长期存活进入老年代
    - 相同年龄所有对象大小过半，以此为年限
    - 空间分配担保：
      - minor GC 前先检查老年代最大可用连续空间是否大于新生代所有对象总空间，成立则可确保安全
      - 若允许担保失败，则继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，若大于则尝试进行一次 minor GC，存在风险；若小于或不允许担保失败则直接 Full GC 
  - Minor GC：新生代 GC，频繁，速度快
  - Major GC / Full GC：老生代 GC，少，慢



3. JVM 执行子系统

- Class 结构
  - 魔数：u4：确定该文件是否为一个能被虚拟机接受的 class 文件 
  - class 文件版本号：u4
  - 常量池：
    - 字面量：字符串、final 常量
    - 符号引用：类和接口、字段名称、方法名称
  - 访问标志：识别类和接口层次的访问信息
  - 类索引、父类索引、接口索引：自身类、继承类、实现类
  - 字段表集合：接口或类中声明的变量
  - 方法表集合
  - 属性表集合
- 字节码指令：面向操作数栈的架构
  - JVM 规定只有在除数为 0 才报错
  - JVM 规定在浮点运算时所有运算结果必须舍入到适当精度



4. JVM 类加载机制

- 初始化时机
  - new 一个实例化对象、读取或设置一个类的 static 字段或调用 static 方法
  - 反射调用
  - 父类未初始化则立即初始化
  - 用户指定的执行主类（包含 main 的那个）
  - MethodHandle 类的方法句柄所对应的类
  - 注：
    - 通过子类引用父类静态字段不会使子类初始化，对于静态字段，只有直接定义这个字段的类才会被初始化
    - 通过数组引用类不会触发初始化
    - 常量在编译阶段已被存入常量池，并未直接引用类不存在初始化
    - 接口初始化时并不要求父接口完成初始化
- 类加载过程
  - 加载
    - 通过类的全限定名获取类的二进制字节流 --> 静态存储结构转化为方法区的运行时数据结构 --> 在内存中生成代表该类的对象
    - 非数组类：系统提供或用户自定义的引导类加载器
    - 数组类：JVM 直接创建
  - 验证
    - 文件格式验证
    - 元数据验证
    - 字节码验证
    - 符号引用验证
  - 准备
    - 正式为类变量（static 修饰）在方法区分配内存并设置类变量初始值（为 0）（区别于初始化）
    - 但若同时被 final 修饰则还是会赋值
  - 解析
    - 将常量池内的符号引用替换为直接引用
    - 符号引用：字符串描述的引用目标，引用目标不一定在内存中，与 JVM 内存布局无关
    - 常量引用：直接或间接指向目标的指针，与 JVM 内存布局有关
  - 初始化
    - 执行类构造器 < clinit >() 方法的过程
  - 类加载器
    - 双亲委派类加载器



5. JVM 字节码执行引擎

- 运行时栈帧结构
  - 局部变量表
  - 操作栈
  - 动态连接
  - 返回地址
- 分派
  - 静态分派：编译器在重载时是通过参数的静态类型而非实际类型作为判定依据
    - 发生在编译阶段，典型为方法重载
    - 静态分派顺序：char->int->long->float->double->Character->Serializable->Object->char[]
  - 动态分派

